#import "../lib.typ": col
#import "@preview/big-todo:0.2.0": *
#pagebreak()
#col[
== Contributions of Philipp Wendt
Like the other members of the group, I spent crucial time on ideas, concepts and other aspects of the early project phases. The following however will be based on my work during the development phase and how the ways I contributed changed over the course of the project and how they differed from the initial planning.

After initial planning, I decided to participate in the project as a part of the `Visual Scripting` team, laying the focus of my work on the node system and its corresponding components. Additionally, I was assigned to the following work packages: `Proof of Concept`, `Node Types`, `Node Execution`, `Unit Tests`, `User Testing` and `Help Tool`.

This however contrasts with the actual work I did during the project, which was heavily influenced by my own time mismanagement and the general communication issues within the team. This led to me falling behind on my initial work, especially within the first weeks of the development phase and having to catch up on work later in the project, which resulted in a lot of stress and frustration for myself as well as the other team members.

In practice I worked on `Proof of Concept`, `Node Types`, `Node Execution` and `User Testing` as well as slightly branching out to the `Game Side` of our application as will later be described in @philipp_dev_phase. Furthermore, I was highly involved in the `Documentation` phase, putting in serious time and effort  to ensure that all aspects of the project were well-documented and presented in a clear and concise manner, as well as catching up on the hours of work I fell short on during early project stages. The following sections will detail my contributions to the project, including the phases I was involved in, the work packages I contributed to, and the challenges I faced along the way.

=== Project Planning<philipp_project_planning>
=== Concept and Design<philipp_concept_design>
During the concept and design phase, I was tasked with contributing to the initial ideas and concepts of the project, particularly focusing on the wireframe and user interface design. I worked closely with the team to develop a clear vision for the project, ensuring that our goals were aligned and that we had a solid foundation to build upon. 

We conducted brainstorming sessions via Discord and Figma, where we shared our ideas and collaborated on the design of the application. Due to me not being familiar with Figma, I assumed more of a feedback role during these sessions, providing input on the design and layout of the application based on my understanding of user experience and usability principles. I frequently provided feedback and suggestions on how to improve the wireframe as well as the overall design language and user interface of the application. This led to me not being able to contribute as much as I would have liked to during this phase, but I was still able to provide valuable input on the design and layout of the application.

This feedback role carried over into the development phase, where I continued to provide feedback on the design and usability of the application, ensuring that our goals were met and that the application was user-friendly, intuitive and visually pleasing.

=== Development<philipp_dev_phase>

I began my contributions to the development on the 22nd of April, where I developed the first ever node for our React Flow Node System, which was a simple `Value` node. This served as the entry to my work on the `Node Types` and `Node Execution` work packages. However, this would be the last node I would create as I quickly fell behind on my initial work due to not putting in enough time and effort into the project during the first weeks of the development phase. This led to the rest of the nodes as well as the underlying logic of the node system being created by Jonathan, thereby also merging `Node Types` and `Node Execution` into one package.

Given the good state our Nodes were in, I started working on the first implementations of Context Menus for our Node Editor, such as a `Pane Context Menu` opening on right click, which would allow the user to create new nodes. Furthermore I also colaborated with Jonathan on the `Selection Context Menu`, a node actions menu for a selection of multiple nodes, based on the `Node Context Menu` by Jonathan. 

At the same time, I also tapped into the `Game Side` of our application a bit, as I rewrote the logic for key registration in our application, which was previously handled through React Flow, limiting the user to only being able to use one key at a time. I chose to implement a more flexible solution, registering key presses through the Kaplay game engine and passing them through to a store which could then be used by the Node Editor. This allowed for more than one key to be pressed at the same time, which was a crucial feature for a proper movement controller node tree, for example. This specific implementation was later scrapped and reworked by Leo, into a completely independent key registration system.

Following a suggestion by Leo, I spent significant time trying to implement an `Undo/Redo` system for the Node Editor, which would allow users to undo and redo their actions within the Node Editor. This was a challenging task, as it required a deep understanding of the state management of the Node Editor and how to effectively track changes made by the user. I was able to implement a basic version of the `Undo/Redo` system, which however was severely flawed and not usable at the time. Sadly I was not able to fix the issues with the system, leading to postponing the feature for the time being in order to focus on more crucial tasks. This was later picked up by Leo and Jonathan, who were able to implement a more robust and functional `Undo/Redo` system, which greatly improved the usability of the Node Editor.

Having worked on the context menus also meant that I worked on the Node Editor itself, which had been a pretty messy piece of code after a few weeks of development, with multiple people working on it at the same time. I was able to clean up the code, refactoring it to be more readable and maintainable. This was achieved by sorting multiple functions into their own hooks. This cleanup was not only conducted on the Node Editor, but also on the Context Menus, ensuring that the code was well-structured and readable, making it easier to work on in the future.

After the refactor I began working on quality of life improvements for the Node Editor, as well as fixes for existing problems, as there were a lot of suggestions from the team on how to improve the usability of the application. As Jonathan had recently written a function that would detect cyclic node connections and highlight them. I picked this up, modified it to make it reusable and then added a warning to export nodes if there is more than one exporting to the same game object at a time. The highlighting creates a colored border around the problematic nodes with the color varying based on severity. On top of that I added a Toast Component that would display a message to the user, informing them about the issue and how to resolve it. I put significant effort into this, implementing features like pausing the timeout for the notification on hover by myself. However there was a better solution using the `sonner` library, as the toast was later reworked and improved by Leo using said library.

To improve the usability of the Node Editor, I started working on a list of shortcuts for the Node Editor, which would allow users to quickly access common actions and features within the Node Editor. This was a crucial feature, as it would greatly improve the usability of the application and make it easier for users to navigate and use the Node Editor. I expanded upon the newly written key registration system by Leo, creating a list of shortcuts the key listener would listen to and then trigger the corresponding action within the Node Editor. This was a challenging task as I implemented all features manually. I managed to administer shortcuts for duplicating nodes, using duplication logic written by Jonathan and Milan, as well as a shortcut for opening the `Node Add Menu` at the position of the mouse cursor, posing an alternative to the pane right click context menu. Lastly I made it so that pressing the `Escape` key would close any open menu, being a common and intuitive feature in many applications.

The following days I spent working on bug fixes and quality of life improvements for the Node Editor, such as fixing an issue with the `Node Add Menu` not closing when clicking outside of it or shortcuts also triggering key press nodes within the Node Editor.

While working on a mac compatible variant of each Shortcut I was quickly faced with a problem: I could not identify a feasible main modifier for each shortcut, as using the `Command` or `Option` key would result in many of our shortcuts clashing with existing macOS shortcuts, which could not be overwritten. In addition to this, I was not able to implement a solution using the `Option` key at first, as it would modify the key code of each pressed key before I could read it properly in the key listener. I decided to use the `Shift` key as a substitute, though it would have potentially clashed with key operations within levels of the game.

After some bug fixes and discussion with the group, I was tasked with a complete rework of our Key registration management including the shortcuts, as they obstructed the current key listener severely and led to conflicts within the code. I completely got rid of the manual logic I implemented for the use of shortcuts and instead used an existing library called `react-hotkeys-hook` @klaussJohannesKlaussReacthotkeyshook2025, which would allow us to register key presses and shortcuts in a more efficient and reliable way. This was a significant improvement, as it allowed us to easily manage key presses and shortcuts without having to manually write the logic ourselves. I was able to implement this solution within a few days. Because my previously written code within the key listener had become obsolete, I reverted the key listener to its original state, as developed by Leo. Through the hotkey library I was able to add a mac compatible variant of each shortcut, using the `Option` key as the main modifier for each shortcut. This allowed us to have a consistent and intuitive set of shortcuts for both Windows and macOS users, greatly improving the usability of the Node Editor. As the new undo/redo system was also finished by that time, I also added shortcuts for undoing and redoing actions within the Node Editor.

Building upon what I learned from the key rewrite, I also implemented a demanded Copy and Paste feature using shortcuts as well as modifying the existing node context menus to include Copy and Paste options. While my other shortcuts had relied on already existing logic, I had to implement the Copy and clipboard logic from scratch. Furthermore I expanded on the existing duplication logic, making it also suitable for pasting copied nodes, as it would have been redundant to implement a completely new logic for pasting nodes. I also added a paste button to the pane right click menu which would appear when a user has nodes copied to their clipboard. I was able to implement this feature within a timely manner and fix all existing bugs, ensuring that everything worked as intended. This feature greatly improved the usability of the Node Editor, allowing users to easily copy and paste nodes and their connections, making it easier to create and manage complex node setups.

=== Documentation<philipp_documentation>

// Finally, I also contributed to the documentation phase, where I was able to write a significant amount of the documentation, documenting my own efforts and development phase (@philipp_dev_phase) and help with the final touches of the project. This included writing the final report, which was a collaborative effort with the other team members, and ensuring that all aspects of the project were well-documented and presented in a clear and concise manner.

// this is also a stretch for now, but im confident this will be true by the end of the project
=== Time Tracking Methodology <philipp_time_methodology>

Similar to Jonathan's approach, I tried to not overestimate my time spent on tasks and kept a rather conservative approach to time tracking. I would look at the time I started working on a task and the time I finished it, then subtracting the time I spent on breaks or other distractions. If I was not sure about the time I spent on a task, I would always round down about half an hour, ensuring that I did not overestimate my time spent on tasks. This approach allowed me to keep track of my time spent on tasks without overestimating it, ensuring that I had a realistic view of my contributions to the project. 
Like Jonathan and Leo I also used the same Git-based time tracking tool, to estimate my time spent on programming tasks even before formal time tracking was introduced. This is further detailed in @jonathan_time_methodology.

=== Time Spent
]